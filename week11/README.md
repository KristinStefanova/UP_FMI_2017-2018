# Практикум #11

## Какво научихме предния път?
* Указатели и референции
* Указатели и масиви
* Функции(advanced level)
* Решавахме задачи

## Какво ще научим днес?
* Низове

## Символен низ
Вече видяхме какво са низовете. Днес ще припомним и допълним. Масив от тип char се нарича  **символен низ**. 
Примери:
    
     "Informacionni sistemi"
     "My name is Mery"
     "" // празен низ
     "My name" // подниз на "My name is Mery"

Низовете се използват за образуване на изречения на някой език, обработка на текстове, кодиране на информация, кодиране на команди и други.

### Декларане на символен низ
За да дефинираме низ, просто декларираме масив от тип char и го инициализираме директно:
```c++
char myString [] = "string";
```
Въпреки че, "string" има само 6 букви, C++ автоматично добавя към края на низа нулев терминаторен символ(не е необходимо да го включваме сами). Следователно myString всъщност е масив от дължина 7! Терминаторния символ: \0 - null символ означава край на низ. Този символ не се отпечатва, той просто дава нужната информация на компилатора. Кодът му в ASCII таблицата е 0. 

    char str[100]; - така декларираме масив от тип char със 100 елемента

Броят на емементите може да бъде дазаден и чрез константа, която е предварително дефинирана;
```c++
    const int SIZE = 3;
    char key[SIZE];
```
**Достъпът** до всеки елемент, както при другите масиви, се осъщесвява, чрез индексирана променлива, в която са указани **името на масива** и **индексът**(поредният номер на елемента в масива) поставен в квадратни скоби.
```c++
    key[0]; // индексирането в масиви е от 0 до броя на елементите -1
```
### Инициализация на масиви
##### Първи начин:
    
```c++
    char msg[6] = {'M', 'a', 'r', 'r', 'y', '\0'};
    // msg[0] = M;
    // msg[1] = a;
    // msg[2] = r;
    // msg[3] = r;
    // msg[4] = y;
    // msg[5] = \0;
```

##### Втори начин:

```c++
    char name[6] = "Marry";
```

##### Трети начин:
При деклариране на низове по този начин позволявате на компилатора да изчисли сам дължината на масива. По този начин, ако промените низ по-късно, няма да трябва ръчно да коригирате дължината на масива. Важно е да се отбележи, че низовете следват същите правила като масивите. Това означава, че можете да инициализирате низа при създаването му, но след това не можете да го промените, като използвате оператора за присвояване!
    
```c++
    char name[] = "Marry"; 
```

### Въвеждане и извеждане на низ от клавиатурата
##### Въвеждане:
Има много случаи, в които не знаем предварително колко дълъг ще бъде низът ни. Например, разгледайте задача, в която трябва да поискаме от потребителя да въведе името си. Колко дълго е името му? Не знаем, докато не го напише!В този случай можем да декларираме масив, който е по-голям от необходимия ни:
```c++
    char name[20];
    cin >> name;
```
В гореспоменатата програма сме определили набор от 20 знака за име, предполагайки, че потребителят няма да въведе толкова много знаци. Въпреки че, това се среща често в програмите C/C++, това е лоша практика, защото нищо не спира потребителя да въведе повече от 20 знака (неволно или злонамерено). Препоръчителният начин за четене на низове от стандартния вход е:
```c++
    char name[20];
    cin.getline(name, 20);
```
**cin.getline()** ще прочете 19 знака, оставяйки място за нулевия терминаторен символ. Всички излишни знаци ще бъдат отхвърлени. По този начин гарантираме, че няма да препилним масива!

##### Извеждане:
При отпечатване на низ cout отпечатва символите, докато не срещне нулев терминатор(\0). Ако случайно null терминатора липсва в низа, не само ще получите всички символи в низа, но std :: cout просто ще продължи да отпечатва всичко в съседните слоеве на паметта, докато не стигне до символа \0!

```c++
    char name[20];
    //    ...
    cout << name;
```
### Допустими операции
Директни операции над цели низове ***не са допустими***.

```c++
    char a[5], b[] = "abv";
    a = b;  // недопустима операция
```

### Вградени функции за работа с низове
В библиотеката **cstring / string.h** има готови функции за работа с низове.
Примери:
 
    strlen(<name_of_string>) // намира дължината на низа
    strcpy(<name_of_str1>, <name_of_str2>) // копира  str2 в str1 
    strncpy(<name_of_str1>, <name_of_str2>, n) // копира първите n символа от str2 в str1
    strcmp(<name_of_str1>, <name_of_str2>) // сравнява лексикографски str1 и str2 връща стойност:
            0 - ако двата низа са равни
            1 - ако str1 е по - голям от str2
           -1 - ако str1 е по - малък от str2
    strncmp(<name_of_str1>, <name_of_str2>,n) // сравнява лексикографски n на брой символи от str1 и str2 
    връща стойност:
            0 - ако двата подниза са равни
            1 - ако str1 е по - голям от str2
           -1 - ако str1 е по - малък от str2
