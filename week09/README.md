# Практикум #9

## Какво научихме предния път?
* Функции

## Какво ще научим днес?
* Указатели и псевдоними
* Указатели и масиви
* Указатели, псевдоними и функции
* Масиви и функции

## Указатели и псевдоними (Pointers and References)
### За какво са и за какво ни трябват?
В началото, когато разбрахме какво са променливите, ние отбелязахме, че променлива е име(идентификатор) за клетка от паметта, която съдържа стойност. Когато нашата програма създава променлива, свободнен адрес на клетка в паметта автоматично се присвоява на променливата и всяка стойност, която даваме на променливата се съхранява в този адрес на паметта.

Например:
```c++
	int x;
```
Когато тази опрерация се изпълнява, CPU отделя част от RAM паметта с размер 4 байта. За примера, нека кажем, че променливата x е сложена на адрес 140 в паметта. Когато програмата вижда променливата x в израз, тя знае, че тя трябва да търси адрес 140 в паметта, за да намери стойността на х. Хубавото за променливите е, че не е нужно да се тревожим за това кой специфичен адрес в паметта е даден. Ние се обръщаме към променливата по дадения й идентификатор и компилаторът превежда това име в подходящо определен адрес в паметта. 

#### Address-of оператор (&)

Address-of(**&**) оператора ни позволява да видим **кой адрес в паметта е присвоен на променлива**. 
Пример:
```c++
#include <iostream>
using namespace std;

int main()
{
    int x = 5;
    cout << x << endl; // ще изведе стойността на х
    cout << &x << endl; // ще изведе адреса в паметта на х
 
    return 0;
}
```
Изход:

	5
	0x7822221582fc

#### Value-of оператор (\*)
Получаването на адреса на променлива не е много полезно само по себе си. Операторът value-of (\*) ни позволява да **получим стойността съхранявана на определен адрес в паметта.**
```c++
#include <iostream>
using namespace std;

int main()
{
    int x = 5;
    cout << x << endl; // ще изведе стойността на х
    cout << &x << endl; // ще изведе адреса в паметта на х
    cout << *x << endl; // ще изведе стойността, съхранявана в клетката с адреса на х
 
    return 0;
}
```
Изход:

	5
	0x7822221582fc
	5

#### Указатели (Pointers)
Указателят е **променлива**(NВ! има тип!), която **съхранява адрес в паметта като стойност**. Както променливата от тип int съхранява цяло число, или както променливата от тип bool съхранява true или false, така и указателят съхранява адрес от вида 0x7822221582fc.

##### Декларация на указател
Указателите се **декларират като обикновени променливи**, с изключение на това че, се поставя символ \* между типа и името на указателя.
```c++

int *iPtr; // указател към променлива от тип int
double *dPtr; // указател към променлива от тип double
 
int* iPtr2; // това също е валидно, но го избягвайте
int * iPtr3; // това също е валидно, но го избягвайте
 
int *iPtr4, *iPtr5; // два указателя към променливи от тип int
```
При деклариране на няколко указателя, към всеки указател трябва да бъде сложена нова \*. *Лесно е да забравите да направите това, ако свикнете да прикрепите звездичката към типа, вместо към името на променливата!*
```c++
int * iPtr6, iPtr7; // iPtr6 е указател към int, а iPtr7 е просто обикновен int!
```
#### Инициализация
##### Синтаксис и семантика:
```c++
<object_type> *<object_name_pointer> = &<object_name_transmitter>;
```	
Пример:
```c++
int a = 50;
int *ptr = &a;
```
По този начин правим следното: създали сме променлива от тип int и сме я инициализирали със стойност 50, след това създаваме променлива от тип указател към int на когото присвояваме адреса на а. Вземането на адрес на дадена променлива се прави чрез &(както казахме по-горе). **Най - важното е да се разбере, че указателите пазят адреса към паметта на това, с което искаме да оперираме.**

![alt tag](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week09/diagrams/MemoryPointer.png)

Пример:
```c++
int a = 50;
int *ptr = &a;

std::cout << *ptr << std::endl; // 50
std::cout << ++*ptr << std::endl; // 51
std::cout << a << std::endl; // 51

```

#### Const
Досега всички указатели, които виждяхме не-константни указатели към не-константни стойности:
```c++
int value = 5;
int *ptr = &value;
*ptr = 6; // променяме стойността на 6
```
Какво обаче се случва, ако е const int value?
```c++
const int value = 5; // value е константа
int *ptr = &value; // compile error: cannot convert const int* to int*
*ptr = 6; // променяме стойността на 6
```
Горният фрагмент няма да се компилира - не можем да зададем указател без const за променлива c const. Това има смисъл: const е променлива, чиято стойност не може да бъде променена. Ако можем да зададем не-константен указател на константна стойност, тогава чрез value-of оператора ще можем да променим стойността. Това би нарушило идеята на const като цяло. Затова има няколко много важни правила кога и как да се използват константи и указатели.

##### Указател към константа
Указател към const стойност е **не-константен указател**, който сочи към **постоянна стойност**(константа).
```c++
const int value = 5;
const int *ptr = &value; // ptr сочи към "const int"
*ptr = 6; // Не е позволено, защото сочи към константа
```
Нека обърнем внимание на следния пример:
```c++
int value = 5; // value не е константа !!!
const int *ptr = &value; // ptr сочи към "const int", но все още е валидно
*ptr = 6; // Не е позволено, защото сочи към константна 
value = 6; // Обаче това е позволено, защото достъпваме променливата чрез нейния идентификатор
```
**Указател към константа може да сочи към не-константна променлива.** Мислете за това по този начин: указател към константа се отнася към променливата, като към константа, независимо от това дали променливата първоначално е била определена като const или не.

Тъй като **указател към константа не е константен указател**(той просто сочи към постоянна стойност), указателя може да бъде пренасочен към други стойности:
```c++
int value1 = 5;
const int *ptr = &value1; // ptr сочи към "const int"
 
int value2 = 6;
ptr = &value2; // okay, сега ptr сочи към нова стойност "const int"
```

##### Константен указател
Също така можем да направим самият указател константен(постоянен). Константният указател е **указател, чиято стойност не може да се променя след инициализация**. За да декларирате константен указател, използвайте ключовата дума **const между \* и името на указателя:**
```c++
int value = 5;
int *const ptr = &value;
```
Точно като нормална константа, константния указател **трябва да се инициализира със стойност при декларацията си**. Това означава, че **константният указател винаги ще сочи един и същ адрес**. В горния случай ptr винаги ще сочи адреса на value. 
```c++
int value1 = 5;
int value2 = 6;
 
int * const ptr = &value1; // okay, константния указател ptr е инициализиран с адреса на value1
ptr = &value2; // not okay, веднъж инициализиран, не може да сочи другаде(да бъде променян)
```
Въпреки това, тъй като стойността, към която сочи, все още не е константа, е възможно да се **промени стойността**, която се сочи.
```c++
int value = 5;
int *const ptr = &value; // ptr винаги ще сочи към адреса на value
*ptr = 6; // позволено, сочи към променлива
```

##### Константен указател към константа

И накрая, възможно е да се дефинира константен указател към константна стойност с помощта на ключовата дума const, **както преди типа, така и преди името на променливата:**
```c++
int value = 5;
const int *const ptr = &value;
```
Константния указател към константа **не може да бъде пренасочен друг адрес, нито пък стойността, която сочи, да бъде променена чрез указателя(независимо дали сочи константа или променлива).**


#### Трябва само да запомните 4 правила и те са доста логични:

* Неконстантен указател, може да бъде пренасовчан към други адреси
* Константният указател, сочи към един и същ адрес, и този адрес не може да бъде променян
* На указател към неконстантна стойност може да се променя стойността, която той сочи. Те не могат да сочат към константа.
* Указател към константна стойност се отнася към стойността като към константа(дори и да не е), и по този начин не може да се промени стойността, която те сочат.

```c++
int value = 5;
const int *ptr1 = &value; // ptr1 сочи към "const int", това е указател към константа
int *const ptr2 = &value; // ptr2 сочи към "int", това е константен указател, към неконстантна стойност(променлива)
const int *const ptr3 = &value; // ptr3 сочи към "const int", това е константен указател към константа
```

#### Псевдоними







#### Масиви и указатели
Споменахме ли, че масивът е указател? Трудно е да повявате? Създайте масив (да кажем от double), след това напишете:
```c++
double arr[5] = { 4, 5, 6, 7.6, 9 };
std::cout << arr << std::endl; // Ще се изпише на конзолата: 0x7ffcd4326470 
```
Това е така, защото когато създаваме масив ние всъщност създаваме указател към първия елемент на масива и когато казваме arr[index] (еквивалентно е *(arr + index)) казваме дай ми елементът, който се намира на позицията: на първия елемент + отместване

#### Псевдоними и указатели във функции
Когато използваме функции(както го правим до сега) и подаваме даден аргумент (подаване по стойност), ние дефакто създаваме нова променлива някъде в паметта (виж графиката) и всички промени които осъществим се правят над новата променлива, но не и над променливата която сме подали.

За да правим промени над оригиналните променливи, които сме подали, се използват указателите и псевдонимите. 

Казано разговорно какво представляват:
	- Псевдонимът казва, когато подадеш дадена променлива, на тази която се присвоява, направо я взима по референция, т.е направо я вземи където се намира по адреса, който е и оперира в оригиналната памет.
	- Указател - подаваме адреса на променливата и оперираме над него

![alt tag](https://github.com/GeorgiMinkov/FMI_IS_UP_1_2016/blob/master/week12/1Diagram.png)

Пример: Искаме да намерим сумата на две числа, като използваме трета променлива в която да се пази резултата. (т.е за учебна цел няма да връщам сумата като резултат, а ще пазя резултата в предварително създадена променлива)

```c++
// Example program
#include <iostream>

// without reference or pointer => will lose value of sum
void sumWithoutRefOrPointer(int numL, int numR, int sum)
{
    sum = numL + numR;
}

// with reference
void sumIt(int numL, int numR, int &sum)
{
    sum = numL + numR;
}

// with pointer
void sumIt(int numL, int numR, int *sum)
{
    *sum = numL + numR;
}

int main()
{
  int numL = 4, numR = 6, sum = 0;
  
  sumWithoutRefOrPointer(numL, numR, sum);
  std::cout << "1) " << sum << std::endl; // 0
  
  sumIt(numL, numR, sum);
  std::cout << "2) " << sum << std::endl; // 10
  
  sumIt(numL + 1, numR, &sum); // we must put adress of sum
  std::cout << "3) " << sum << std::endl; // 11

  return 0;

}
```

Виждаме това което коментираме до сега. Там къде сме подали по стойност (т.е. първата функция), правим копие и след края на изпълнение се трие това копие, като стойността на sum (това е main) не е променена.
Когато подаваме по референция ние работим директно в паметта и от там идва и промяната на стойността на променливата sum.
При използването на указател наблюдаваме същото, вземи адреса на променливата и след това с * казваме влез вътре и промени стойността.

