# Quiz #13


**1. Тази функция е пример за какъв тип рекурсия?**
```c++
int fib_r(int n)
{
    if (n<=1) 
        return 1;
    else 
        return(fib_r(n-1) + fib_r(n-2));
}
```
A. Линейна рекурсия

B. Опашата рекурсия

C. Двоична рекурсия

D. Вложена рекурсия


**2. fibоnacii(5) e**

A. 2

B. 3

C. 5

D. 8


**3. factorial(4) e**

A. 0

B. 24

C. 12

D. 36


**4. Вярно или невярно: Ако рекурсивната функция няма основен случай, компилаторът ще открие това и ще покаже грешка на компилатора.**

A. Вярно

B. Невярно


**5. Вярно или невярно: Рекурсивните извикваня обикновено се съдържат в цикъл.**

A. Вярно

B. Невярно


**6. Вярно или невярно: Възможно е да има повече от едно рекурсивно повикване в дадена функция.**

A. Вярно

B. Невярно


**7. Вярно или невярно: Двоичното търсене може да бъде написано само рекурсивно.**

A. Вярно

B. Невярно


**8. Кое от тези твърдения е вярно за следния код?**
```c++
int foo(int n)
{
    if (n > 0) 
        return n + foo(n-1);
    return 0;
}
```
A. Основният случай е всяка стойност на аргумента да е по-малка или равна на нула.

Б. Основният случай е всяка стойност на аргумента да е по-голяма от нула.

C. Основният случай е всяка стойност на аргумента да е равна на нула.

D. Няма основен случай


**9. Коя от следните итеративни функции не е еквивалентна на тази рекурсивна функция?**
```c++
int foo(int n)
{
    if(n > 0) 
         return (n + foo(n - 1));
    return 0;
}
```

A. 
```c++
int foo(int n) 
{
    int sum = 0;
    while (n > 0) 
    {
        sum = sum + n;
        n--;
    }
    return sum;
}
``` 

B.
```c++
int foo(int n) 
{
    int j = 0, sum = 0;
    while (j < n) 
    {
        j++;
        sum = sum + j;
    }
    return sum;
}
```
 
C. 
```c++
int foo(int n) 
{
    int sum;
    while (n > 0) 
    {
        sum = 0;
        sum = sum + n;
        n--;
    }
    return sum;
}
```

**10. Вярно или невярно: Когато елегантността на рекурсивното решение надвишава нейните разходи (памет, време, ефективност и т.н.) и когато е много по-лесно от едно итеративно решение, най-вероятно ще решите да използвате рекурсивното решение.**

A. Вярно

B. Невярно


**11. Вярно или невярно: Винаги трябва да използвате по-скоро рекурсивно, отколкото итеративно решение, когато сте сигурни, че това рекурсивно решение няма да препълни стека.**

A. Вярно

B. Невярно


**12. Рекурсията може да бъде неефективен начин за реализиране на решение, защото:**

A. използвайки стека за съхраняване на състоянията си използва значително много ресурси.

B. извикването на функция няколко пъти би могло да се сведе до цикличност, което би могло да бъде направено по-ефективно с цикъл

C. и двете


**13. Вярно или невярно: Рекурсията се случва, когато алгоритъмът не използва цикличност(повторение).**

A. Вярно

B. Невярно


**14. Вярно или невярно: Функция може да се счита за рекурсивна, ако тя има пряко или непряко обръщение към себе си.**

A. Вярно

B. Невярно


**15. Вярно или невярно: Безкрайната рекурсия може да настъпи, когато рекурсивния алгоритъм не съдържа базов(основен) случай.**

A. Вярно

B. Невярно


**16. Какво прави следната функция?**
```c++
int foo(int x, int y)
{
    if (y == 0)   
        return 0;
    return (x + foo(x, y-1));
}
```
A. x + y

B. x + x\*y

C. x\*y

D. Нищо

**17. Какво прави foo2() като цяло?**
```c++
int foo(int x, int y)
{
    if (y == 0)   
        return 0;
    return (x + foo(x, y-1));
}
 
int foo2(int a, int b)
{
    if (b == 0) 
        return 1;
    return foo(a, foo2(a, b-1));
}
```
A. x\*y

B. x+x\*y

C. x^y

D. Нищо

**18. Какъв ще е резултата от следната програма?**
```c++
#include<iostream>

void print(int n)
{
    if (n > 4000)
        return;
    cout << n << " ";
    print(2 * n);
    cout << n << " ";
}
 
int main()
{
    print(1000);
    return 0;
}
```
A. 1000 2000 4000

B. 1000 2000 4000 4000 2000 1000

C. 1000 2000 4000 2000 1000

D. 1000 2000 2000 1000


**19. Какво прави следната финкция?**
```c++
int foo(unsigned int n)
{
    if (n == 0 || n == 1)
        return n;
 
    if (n%3 != 0)
        return 0;
 
    return foo(n/3);
}
```
A. Връща 1, когато n е кратно на 3, в противен случай връща 0

B. Връща 1, когато n е степен на 3, в противен случай връща 0

C. Връща 0, когато n е кратно на 3, в противен случай връща 1

D. Връща 0, когато n е степен на 3, в противен случай връща 1


**20. Какъв ще е резултата от следната програма?**
```c++
#include <iostream>

int foo(int n)
{
    if(n <= 1)
        return 1;
    if(n % 2 == 0)
        return foo(n/2);
    return foo(n/2) + foo(n/2+1);
}
 
 
int main()
{
   std::cout << foo(11);
    return 0;
}
```
A. Stack Overflow

B. 3

C. 4

D. 5
