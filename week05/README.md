# Практикум #5
## Какво научихме предният път?
* Конструкции за цикли
	* Оператор break и continue
	* Вложени цикли
## Какво ще научим днес?
* структурни типове данни
* едномерни масиви

## Структурни типове данни
Когато е необходимо да пазим и обработваме количествена информация(например: работните часове на 100 работника в някоя фирма)вместо да използваме 100 различни променливи и да помним коя за кой работник се използва, можем да използваме структурни(още съставни) типове данни.

## Масиви
Масивът е структурен (съставен) тип данни, представляващ крайна редица от **еднотипни елементи** с **пряк достъп до всеки елемент**. Масивът е съвкупен тип данни, който ни позволява да осъществим достъп до много променливи от един и същи тип чрез идентификатор. В декларацията  на масива използваме квадратни скоби ([]), за да кажем на компилатора, че това е променлива от тип масив(вместо нормална променлива), както и колко променливи да се заделят в паметта(наречени дължина на масива). 

### Памет

Паметта, която можете да използвате в C++ програма е най-общо казано три типа:
* статична

в тази памет се записват променливите, обявени извън функциите (т.нар. глобални променливи). Те се виждат от всички функции през цялото изпълнение на програмата
* стекова

в тази памет се записват предадените параметри и променливите дефинирани вътре във функциите и въобще в произволен блок. Променливите се виждат само във функцията (блока) в която са дефинирани и се унищожават при завършване на функцията (излизане от блока)
* динамична

останалата част от паметта на компютърна е достъпна до всички програми при поискване. За управлението на тази памет се грижи операционната система  . Във всеки момент отделен блок от паметта може да е свободен или да е заделен за някоя програма, при която може да го чете само тя. При опит някоя програма да прочете памет, която не е заделена за нея, независимо дали е заделена за друга програма или е свободна, операционната система прекратява изпълнението на програмат с грешка Access Violation

![alt tag](https://github.com/KristinStefanova/UP_FMI_IS_2017-2018/blob/master/week05/diagrams/memory.png)

### Декларане на масив
За изграждането на масив най-важното което, трябва да определим е **броят на елементите** му и **техният тип**.
    
    int arr[5]; - така декларираме масив от тип int с 5 елемента
    double dArr[10]; - така декларираме масив от тип double с 10 елемента
    char str[100]; - така декларираме масив от тип char със 100 елемента

Броят на емементите може да бъде дазаден и чрез константа, която е предварително дефинирана;
```c++
    const int n = 3;
    long array[n];
```
Достъпът до всеки елемент се осъщесвява, чрез индексирана променлива, в която са указани **името на масива** и **индексът**(поредният номер на елемента в масива) поставен в квадратни скоби.
```c++
    array[0]; // индексирането в масиви е от 0 до броя на елементите -1
```
### Инициализация на масиви
##### Първи начин:
    
```c++
    int arr[5];
    arr[0] = 5;
    arr[1] = -3;
    arr[2] = 12;
    arr[3] = 6;
    arr[4] = 123015;
```

##### Втори начин:

```c++
    int arr[5] = {5, -3, 12, 6, 123015};
```

##### Трети начин:
    
```c++
    int arr[] = {5, -3, 12};
```

##### Четвърти начин:
Можем да  инициализираме масив и със стойности, въведени от клавиатурата.
```c++
    double arr[5];
    for(int i = 0; i < 5; i++)
        cin >> arr[i];
```

### Допустими операции
Операции над цели масиви ***не са допустими***.

```c++
    int a[5], b[5] = {1,2};
    a = b;  // недопустима операция
```

### Въвеждане и извеждане на еменетите на масив
#### Въвеждане:

```c++
    double arr[5];
    for(int i = 0; i < 5; i++)
    {
        cout << "arr[ " << i << " ]= ";
        cin >> arr[i];
    }
```

#### Извеждане:

```c++
    double arr[5];
        ...
    for(int i = 0; i < 5; i++)
    {
        cout << "arr[ " << i << " ]= " << arr[i] << endl;
    }
```

## Символен низ
Масив от тип char се нарича  **символен низ**. 
Примери:
    
     "Informacionni sistemi"
     "My name is Mery"
     "" // празен низ
     "My name" // подниз на "My name is Mery"

Низовете се използват за образуване на изречения на някой език, обработка на текстове, кодиране на информация, кодиране на команди и други.

### Декларане на символен низ
    char str[100]; - така декларираме масив от тип char със 100 елемента

Броят на емементите може да бъде дазаден и чрез константа, която е предварително дефинирана;
```c++
    const int SIZE = 3;
    char key[SIZE];
```
Достъпът до всеки елемент, както при другите масиви, се осъщесвява, чрез индексирана променлива, в която са указани **името на масива** и **индексът**(поредният номер на елемента в масива) поставен в квадратни скоби.
```c++
    key[0]; // индексирането в масиви е от 0 до броя на елементите -1
```
### Инициализация на масиви
##### Първи начин:
    
```c++
    char msg[6] = {'M', 'a', 'r', 'r', 'y'};
    // msg[0] = M;
    // msg[1] = a;
    // msg[2] = r;
    // msg[3] = r;
    // msg[4] = y;
    // msg[5] = \0;
```

##### Втори начин:

```c++
    char name[6] = "Marry";
```

##### Трети начин:
    
```c++
    char name[] = "Marry"; 
```

### Въвеждане и извеждане на низ от клавиатурата
##### Въвеждане:

```c++
    char name[20];
    cin >> name;
```

##### Извеждане:

```c++
    char name[20];
    //    ...
    cout << name;
```
### Допустими операции
Директни операции над цели низове ***не са допустими***.

```c++
    char a[5], b[] = "abv";
    a = b;  // недопустима операция
```

### Вградени функции за работа с низове
В библиотеката **cstring / string.h** има готови функции за работа с низове.
Примери:
 
    strlen(<name_of_string>) // намира дължината на низа
    strcpy(<name_of_str1>, <name_of_str2>) // копира  str2 в str1 
    strncpy(<name_of_str1>, <name_of_str2>, n) // копира първите n символа от str2 в str1
    strcmp(<name_of_str1>, <name_of_str2>) // сравнява лексикографски str1 и str2 връща стойност:
            0 - ако двата низа са равни
            1 - ако str1 е по - голям от str2
           -1 - ако str1 е по - малък от str2
    strncmp(<name_of_str1>, <name_of_str2>,n) // сравнява лексикографски n на брой символи от str1 и str2 връща стойност:
            0 - ако двата подниза са равни
            1 - ако str1 е по - голям от str2
           -1 - ако str1 е по - малък от str2

