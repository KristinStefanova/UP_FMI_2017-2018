# Quiz #12

**1. При кoe има самоизвикване?**

A. Рекурсията

B. Функцията

C. Нито едно от посочените


**2. Къде има повторение, освен в циклите?**

A. Рекурсията

B. Функцията

C. Нито едно от посочените


**3. Факториел е:**

A. добър основен пример за рекурсия. Функция, която по-добре е имплементирана итеративно, заради ефективността

B. добър основен пример за рекурсия. Функция, която по-добре е имплементирана рекурсивно

C. лош пример за рекурсия, защото трудно се имплементира рекурсивно


**4. factorial(0) е:**

A. 0

B. 1

C. Безкрайност

D. Неопределеност

E. Нито едно от посочените


**5. Рекурсията е:**

A. мощна теоретична конструкция, рядко се използва в реални програми

B. слаба теоретична конструкция, рядко се използва в реални програми.

C. мощна теоретична конструкция, често се използва в определени програми, които се възползват от преимуществата на рекурсивните методи.


**6. Кое от следните не е изискване за рекурсивна функция?**

A. Да има 2 основни случая

B. Да има общ случай

C. Общият случай да се свежда до основен случай

D. Да има основен случай(поне 1)


**7. Финкцията**
```c++
int example(unsigned int a)
{
	if (a==0) 
		return 0;
	else 
		return example(a+1);
}
```
**e ненадежна рекурсивна функция, защото:**

A. няма общ случай

B. няма основен случай

C. общият случай не се свежда до основния


**8. Следващата функция циклична ли е?**
```c++
int foo(int n)
{
	if (n==1) 
		return 0;
	else if (n % 2 != 0) 
		return foo(n/2);
	else 
		return 1 + foo(3*n + 1);
}
```
A. Да

B. Не

C. Може би


**9. Вярно или невярно: Независимо от изпълнението, итеративното решение на проблема на Фибоначи е винаги по-ефективно от рекурсивно решение.**

A. Вярно

B. Невярно


**10. Вярно или невярно: Линейната рекурсивна функция винаги има едно рекурсивно повикване в края на функцията.**

A. Вярно

B. Невярно


**11. Вярно или невярно: Опашатата рекурсия е форма на линейна рекурсия.**

A. Вярно

B. Невярно


**12. Следната функция е пример за какъв вид на рекурсия?**
```c++
int foo(int n, int k)
{
	if (k == 0 || n == k) 
		return 1;
	else 
		return(foo(n-1,k) + foo(n-1,k-1));
}
```
A. Линейна рекурсия

B. Двоична рекурсия

C. Вложена рекурсия

D. Взаимна рекурсия


**13. Следната рекурсивна функция, на коя вградена функция за низове е еквивалентна?**
```c++
int foo(char \*s)
{
	if (\*s=='\0') 
		return 0;
	else 
		return(1 + foo(s+1));
}
```
A. strlen()

B. strcmp()

C. strstr()

D. strchr()



**14. Вярно или невярно: Всички рекурсивни функции могат да бъдат имплементирани итеративно.**

A. Вярно

B. Невярно


**15. Вярно или невярно: Всички итеративни функции могат да бъдат изпълнени рекурсивно.**

A. Вярно

B. Невярно


**16. Какъв е резултата от следната програма?**
```c++
#include <iostream>
 
int foo(int n)
{
    if (n == 4)
        return n;
    else 
		return 2\*foo(n+1);
}
 
 
int main()
{
   std::cout << foo(2);
   return 0;
}
```
A. 4

B. 8

C. 16

D. Error


**17. Имате следната рекурсивна функция foo(x, y). Каква е стойността на foo(4, 3)?**
```c++
int foo(int x, int y) 
{
  if (x == 0)
  	  return y;
  return 
  	  foo(x - 1,  x + y);
} 
```
A. 13

B. 12

C. 9

D. 10


**18. Kaкво ще принтира следната функция за n = 25?**
```c++
void foo(int n)
{
  if (n == 0)
    return;
 
  std::cout << n % 2;
  foo(n/2);
}  
```
A. 11001

B. 10011

C. 11111

D. 00000


**19. Вярно или невярно: Безкрайна рекурсия може да се настъпи, когато рекурсивния алгоритъм съдържа основен случай.**

A. Вярно

B. Невярно


**20. Имате следната рекурсивна функция.**
```c++
unsigned int foo(unsigned int n, unsigned int r) {
  	if (n  > 0) 
		return (n % r +  foo (n / r, r ));
  	else 
		return 0;
}
```
**Какъв ще е резултата от извикването foo(345, 10)?**

A. 345

B. 12

C. 5

D. 3
